package smallcheck
import scala.collection.mutable.ListBuffer

/**
 * A property generates a sequences of test cases for a given depth
 */
trait Property {
  import Property._

  def apply(d: Int): Seq[TestCase]

  /**
   * Map the test cases generated by this property
   */
  def map(f: TestCase => TestCase) = new Property {
    def apply(d: Int) =
      Property.this.apply(d).map(f)
  }

  /**
   * Map the test cases generated by this property to properties
   */
  def flatMap(f: (TestCase) => Property) = new Property {
    def apply(d: Int) =
      Property.this.apply(d).flatMap(f(_).apply(d))
  }

  /**
   * Filter (lazily) the test cases generated by this property
   */
  def withFilter(p: (TestCase) => Boolean) = new WithFilter(p)

  class WithFilter(p: (TestCase) => Boolean) {

    /** map over a filter */
    def map[B](f: (TestCase) => TestCase) = new Property {
      def apply(d: Int): Seq[TestCase] = {
        val buffer = new ListBuffer[TestCase]
        for (tc <- Property.this.apply(d))
          if (p(tc)) buffer += f(tc)
        buffer.toSeq
      }
    }

    /** flatMap over a filter */
    def flatMap[B](f: (TestCase) => Property) = new Property {
      def apply(d: Int): Seq[TestCase] = {
        val buffer = new ListBuffer[TestCase]
        for (tc <- Property.this.apply(d))
          if (p(tc)) buffer ++= f(tc)(d)
        buffer.toSeq
      }
    }

    /** filter over a filter */
    def withFilter(q: TestCase => Boolean) = new WithFilter(x => p(x) && q(x))
  }

  /**
   * Combine this property with that property
   * using a function that combines the generated test cases 
   */
  def combine(that: Property)(f: (TestCase, TestCase) => TestCase) =
    for (tcthis <- this; tcthat <- that) yield f(tcthis, tcthat)

  /**
   * Combine this property with that property
   * so that it holds if and only if both this and that property hold
   */
  def &&(p: Property) = combine(p)(_ && _)

  /**
   * Combine this property with that property
   * so that it holds if and only if either this or that property holds
   */
  def ||(p: Property) = combine(p)(_ || _)

  /**
   * Combine this property with that property
   * so that it holds if and only if this property implies that that property holds
   */
  def ==>(that: => Property): Property =
    this.flatMap { tcthis: TestCase =>
      if (tcthis.passed) {
        that.map { tcthat: TestCase =>
          TestCase.merge(tcthis, tcthat, tcthat.result)
        }
      } else {
        Property(tcthis.copy(result = Inappropriate))
      }
    }

  /**
   * Combine this property with that property
   * so that it holds if an only if, this holds if and only if that holds 
   */
  def <=>(that: Property): Property =
    for {
      tcthis <- this
      tcthat <- that
    } yield TestCase.merge(tcthis, tcthat, if (tcthis.result == tcthat.result) Pass else Fail)
}

/**
 * Methods for building properties
 */
object Property {
  
  /**
   * A testable is a function from a depth to a sequence of test cases
   */
  type Testable = Function1[Int, Seq[TestCase]]
  
  object TestResult {
    implicit def fromBool(b: Boolean): TestResult = if (b) Pass else Fail
  }

  /**
   * An algebraic data type for test results
   */
  sealed abstract class TestResult {
    /** A result is OK if it isn't a failure */
    def isOk: Boolean = this match {
      case Fail => false
      case _ => true
    }
  }

  /** A passing test result */
  case object Pass extends TestResult

  /** A failing test result */
  case object Fail extends TestResult

  /**
   * An inappropriate test result,
   * for when a precondition was unsatisfied
   */
  case object Inappropriate extends TestResult
  
  /** Methods for building test cases */
  object TestCase {
    def apply(result: TestResult) = new TestCase(result, Nil)
    def merge(tc1: TestCase, tc2: TestCase, result: TestResult) = new TestCase(result, tc1.args ++ tc2.args)
  }
  
  /**
   * A test case records the result and the argument for a test
   */
  case class TestCase(result: TestResult, args: Seq[String]) {
    import TestCase.merge

    /** this test case's result is Ok */
    def resultIsOk: Boolean = result.isOk

    /** this test case passed */
    def passed: Boolean = result == Pass

    /** this test case failed */
    def failed: Boolean = result == Fail

    /** this test case was inapproriate */
    def inappropriate: Boolean = result == Inappropriate

    /** Return a copy of this test case with an additional argument */
    def addArg(s: String): TestCase = copy(args = args.+:(s))

    /** Return a copy of this test case with an additional argument */
    def addArg(a: Any): TestCase = addArg(a.toString())

    /** Combine this and that test case by conjunction*/
    def &&(that: TestCase) = (this.result, that.result) match {
      case (Fail, _) => this
      case (_, Fail) => that
      
      case (Inappropriate, _) => this
      case (_, Inappropriate) => that
      
      case (Pass, Pass) => merge(this, that, Pass) 
    }

    /** Combine this and that test case by disjunction */
    def ||(that: TestCase) = (this.result, that.result) match {
      case (Fail, Fail) => merge(this, that, Fail)
      case (Fail, _) => that
      case (_, Fail) => this
      
      case (Pass, _) => this
      case (_, Pass) => that
      
      case (Inappropriate, Inappropriate) => merge(this, that, Inappropriate)
    }

    /** Combine this and that test case by implication */
    def ==>(that: TestCase) = (this.result, that.result) match {
      case (Fail, _) => merge(this, that, Inappropriate)
      case (Inappropriate, _) => this
      case (Pass, _) => merge(this, that, that.result)
    }
  }

  /** A boolean is a trivial testable value */
  implicit def testableBoolean(b: Boolean): Testable = {d: Int => Seq(TestCase(b, Nil))}

  /** A boolean is a trivial property */
  implicit def propBoolean(b: Boolean): Property = new Property {
    def apply(d: Int): Seq[TestCase] = Seq(TestCase(b, Nil))
  }

  /** A property is isomorphic to a testable value */
  implicit def testableProp(p: Property): Testable = p.apply

  /** A property can be built from a testable value */
  def apply(f: Testable): Property = new Property {
    def apply(d: Int): Seq[TestCase] = f(d)
  }

  /** A property can be built from test cases */
  def apply(tc: TestCase*): Property = new Property {
    def apply(d: Int): Seq[TestCase] = Seq(tc:_*)
  }

  /** A property that holds if all the properties in a sequence hold */
  def all(ps: Property*): Property = ps.foldLeft(true:Property)(_ && _)

  /** A property that holds if at least one of the properties in a sequence holds */
  def atLeastOne(ps: Property*): Property = ps.foldLeft(false:Property)(_ || _)
  
  /** 
   * A property that holds
   * for all inputs to a testable unary function
   * from the given series
   */
  def forAll[A,P](sa: Series[A])
                 (f: (A) => P)
                 (implicit test: P => Testable): Property = new Property {
    def apply(d: Int): Seq[TestCase] =
      for {
        a <- sa(d)
        p = f(a)
        t = test(p)
        tc <- t(d)
      } yield tc.addArg(a)
  }

  /** 
   * A property that holds
   * for all inputs to a testable binary function
   * from the given series
   */
  def forAll[A,B,P](sa: Series[A], sb: Series[B])
        (f: (A,B) => P)
        (implicit test: P => Testable): Property =
    forAll(sa){a:A => forAll(sb){f(a, _:B)}}

  /** 
   * A property that holds
   * for all inputs to a testable ternary function
   * from the given series
   */
  def forAll[A,B,C,P](sa: Series[A], sb: Series[B], sc: Series[C])
        (f: (A,B,C) => P)
        (implicit test: P => Testable): Property =
    forAll(sa){a:A => forAll(sb,sc){f(a, _:B, _:C)}}

  /** 
   * A property that holds
   * for all inputs to a testable quaternary function
   * from the given series
   */
  def forAll[A,B,C,D,P](sa: Series[A], sb: Series[B], sc: Series[C], sd: Series[D])
        (f: (A,B,C,D) => P)
        (implicit test: P => Testable): Property =
    forAll(sa){a:A => forAll(sb,sc,sd){f(a, _:B, _:C, _:D)}}

  /** 
   * A property that holds
   * for all inputs to a testable quinary function
   * from the given series
   */
  def forAll[A,B,C,D,E,P](sa: Series[A], sb: Series[B], sc: Series[C], sd: Series[D], se: Series[E])
        (f: (A,B,C,D,E) => P)
        (implicit test: P => Testable): Property =
    forAll(sa){a:A => forAll(sb,sc,sd,se){f(a, _:B, _:C, _:D, _:E)}}

  /** 
   * A property that holds
   * for all inputs to a testable unary function
   */  
  def forAll[A,P](f: (A) => P)
        (implicit test: P => Testable, s: Series[A]): Property =
    forAll(s)(f)(test)

  /** 
   * A property that holds
   * for all inputs to a testable binary function
   */
  def forAll[A,B,P](f: (A,B) => P)
        (implicit test: P => Testable, sa: Series[A], sb: Series[B]): Property =
    forAll{a:A => forAll{f(a, _:B)}}

  /** 
   * A property that holds
   * for all inputs to a testable ternary function
   */
  def forAll[A,B,C,P](f: (A,B,C) => P)
        (implicit test: P => Testable, sa: Series[A], sb: Series[B], sc: Series[C]): Property =
    forAll{a:A => forAll{f(a, _:B, _:C)}}

  /** 
   * A property that holds
   * for all inputs to a testable quaternary function
   */
  def forAll[A,B,C,D,P](f: (A,B,C,D) => P)
        (implicit test: P => Testable, sa: Series[A], sb: Series[B], sc: Series[C], sd: Series[D]): Property =
    forAll{a:A => forAll{f(a, _:B, _:C, _:D)}}

  /** 
   * A property that holds
   * for all inputs to a testable quinary function
   */
  def forAll[A,B,C,D,E,P](f: (A,B,C,D,E) => P)
        (implicit test: P => Testable, sa: Series[A], sb: Series[B], sc: Series[C], sd: Series[D], se: Series[E]): Property =
    forAll{a:A => forAll{f(a, _:B, _:C, _:D, _:E)}}

  /** 
   * A property that holds
   * for all inputs to a testable unary function
   * from the given sequence
   */
  def forAllElem[A,P](s: Seq[A])
                     (f: (A) => P)
                     (implicit test: P => Testable): Property =
    forAll(Series.constant(s))(f)(test)
  
  private def existance[A,P](unique: Boolean, s: Series[A])
                            (f: (A) => P)
                            (implicit test: P => Testable): Property = new Property {
    def apply(d: Int): Seq[TestCase] = {
      val witnesses = for {
    	  				a <- s(d)
    	  				p = f(a)
    	  				t = test(p)
    	  				if t(d).foldLeft(true)((b, tc) => b && tc.resultIsOk)
                      } yield a.toString()
      val valid = if (unique) witnesses.size == 1 else witnesses.nonEmpty
      val arguments = if (valid)
                        Nil
                      else if (witnesses.isEmpty)
                        Seq("non-existence")
                      else
                        "non-uniqueness" :: witnesses.take(2).toList
      Seq(TestCase(valid, arguments))
    }
  }
  
  /** 
   * A property that holds
   * for at least one input to a testable unary function
   * from the given series
   */
  def thereExists[A,P](s: Series[A])
                      (f: (A) => P)
                      (implicit test: P => Testable): Property =
                        existance(false, s)(f)

  /** 
   * A property that holds
   * for exactly one input to a testable unary function
   * from the given series
   */
  def thereExists1[A,P](s: Series[A])
                       (f: (A) => P)
                       (implicit test: P => Testable): Property =
                         existance(true, s)(f)

  /**
   * A property that holds
   * for at least one input to a testable unary function
   * from the given sequence
   */
  def thereExistsElem[A,P](s: Seq[A])
                          (f: (A) => P)
                          (implicit test: P => Testable): Property =
                            existance(false, Series.constant(s))(f)

  /**
   * A property that holds
   * for exactly one input to a testable unary function
   * from the given sequence
   */
  def thereExists1Elem[A,P](s: Seq[A])
                           (f: (A) => P)
                           (implicit test: P => Testable): Property =
                             existance(true, Series.constant(s))(f)

  /**
   * A property that holds
   * for at least one input to a testable unary function
   */
  def exists[A,P](f: (A) => P)
                 (implicit test: P => Testable, s: Series[A]): Property =
                   thereExists(s)(f)

  /**
   * A property that holds
   * for exactly one input to a testable unary function
   */
  def exists1[A,P](f: (A) => P)
                  (implicit test: P => Testable, s: Series[A]): Property =
                    thereExists1(s)(f)
  
  /**
   * A property that holds
   * for at least one input to a testable unary function
   * at a depth given by a deepening function
   */
  def existsDeeperBy[A,P](df: (Int) => Int)
                         (f: (A) => P)
                         (implicit test: P => Testable, s: Series[A]): Property =
                           thereExists(s.deepen(df))(f)
  /**
   * A property that holds
   * for exactly one input to a testable unary function
   * at a depth given by a deepening function
   */
  def exists1DeeperBy[A,P](df: (Int) => Int)
                          (f: (A) => P)
                          (implicit test: P => Testable, s: Series[A]): Property =
                            thereExists1(s.deepen(df))(f)
}
